J'ai fais du reverse engenerine pour comprendre cet exercice.

en faisant un disas main, Avant que la fonction test sois appeller, nous voyons une grosse valeur
0x080488ca <+112>:   movl   $0x1337d00d,0x4(%esp) // 322424845
0x080488d2 <+120>:   mov    %eax,(%esp)
0x080488d5 <+123>:   call   0x8048747 <test>

Puis en faisant un disas test, On vois que la valeur entrer et la grosse valeur sont soustraite puis une comparaison

0x08048759 <+18>:    mov    %eax,-0xc(%ebp)
0x0804875c <+21>:    cmpl   $0x15,-0xc(%ebp)

En gros ca donne (bigValue - valueScanf) < 21

Ensuite nous remarquons dans la fonction, plein de jmp. Je pense donc a une foret de if ou bien un switch
Les cases allant de 1 a 21. Une fois rentrer dans une de ces cases (pas dans la case default).
Nous envoyons dans la fonction decrypt (bigValue - valueScanf), si le chiffre est plus grand que 21, nous envoyons un chiffre au hasard grace a la fonction rand.

En faisant un disas sur la fonction decrypt
4 lignes m'interpelles

0x08048673 <+19>:    movl   $0x757c7d51,-0x1d(%ebp)
0x0804867a <+26>:    movl   $0x67667360,-0x19(%ebp)
0x08048681 <+33>:    movl   $0x7b66737e,-0x15(%ebp)
0x08048688 <+40>:    movl   $0x33617c7d,-0x11(%ebp)

Ce sont des chaines de characteres a decoder (hexa vers ascii) ce qui donne donc "Q}|u`sfg~sf{}|a3"
Plus loin

 0x080486c5 <+101>:   jmp    0x80486e5 <decrypt+133>
0x080486c7 <+103>:   lea    -0x1d(%ebp),%eax
0x080486ca <+106>:   add    -0x28(%ebp),%eax
0x080486cd <+109>:   movzbl (%eax),%eax
0x080486d0 <+112>:   mov    %eax,%edx
0x080486d2 <+114>:   mov    0x8(%ebp),%eax
0x080486d5 <+117>:   xor    %edx,%eax // Here
0x080486d7 <+119>:   mov    %eax,%edx
0x080486d9 <+121>:   lea    -0x1d(%ebp),%eax
0x080486dc <+124>:   add    -0x28(%ebp),%eax
0x080486df <+127>:   mov    %dl,(%eax)
0x080486e1 <+129>:   addl   $0x1,-0x28(%ebp)
0x080486e5 <+133>:   mov    -0x28(%ebp),%eax
0x080486e8 <+136>:   cmp    -0x24(%ebp),%eax
0x080486eb <+139>:   jb     0x80486c7 <decrypt+103>

Nous nous trouvons a l'interieur de la boucle. 
en fesant un p/s (char) $edx, nous voyons que c'est un morceau du tableau "Q}|u`sfg~sf{}|a3" et que $eax contient la valeur envoyer par la fonction test.
En gros ca donne ceci    str[i] = 2 ^ str[i];

Et plus en bas de la fonction, nous voyons un strncmp avec "Congratulation!" en parametre. Pour calculer le bon offset et sachant ue le switch a 21 cases (allant de 1 a 21) nous codons une fonction pour tester les possibilit√©s a notre place.

qui nous donne donc le chiffre 18 donc nous devons rentrer 322424827 et un shell s'ouvre.